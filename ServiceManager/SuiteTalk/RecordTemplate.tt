<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension="\0" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ assembly name="Microsoft.CSharp.dll" #>
<#@ assembly name="System.Web.Services" #>
<#@ include file="T4Toolbox.tt" #>
<#@ assembly name="$(ProjectDir)..\ServiceManager.Design\$(OutDir)ServiceManager.Design.dll" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="com.celigo.net.ServiceManager.SuiteTalk" #>using com.celigo.net.ServiceManager.SuiteTalk;
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#
	var template = new RecordExtenderTemplate();

	foreach (var typeInfo in GetRecordTypes())
	{
		template.TargetType = typeInfo.TargetType;
		template.TypeName   = typeInfo.TypeName;
		template.SupportsCustomFields = null != typeInfo.TargetType.GetProperty("customFieldList") && typeInfo.TargetType.Name != "CustomRecordType";
		template.Output.File = typeInfo.TypeName + ".cs";
		template.Render();		 
	}
#><#+
public class RecordExtenderTemplate : Template
{
	public Type TargetType { get; set; }
	public string TypeName { get; set; }
	public bool SupportsCustomFields { get; set; }
	
	public override string TransformText()
	{
#>//~ Generated by RecordTemplate.tt
#pragma warning disable 1591
using System;

namespace com.celigo.net.ServiceManager.SuiteTalk
{
	public partial class <#= TypeName #><#+ 
		if (SupportsCustomFields)
		{#>
 		: ISupportsCustomFields<CustomFieldRef><#+
		}
		else if (TypeName.EndsWith("CustomField"))
		{#>
		: ICustomFieldDefinition<#+
		}#>
	{
		/// <summary>
		/// Gets the Internal ID.
		/// </summary>
		/// <returns>The Internal ID of the record.</returns>
		public override string GetInternalId()
		{
<#+ if (null != TargetType.GetProperty("internalId")) { #>
			return this.internalIdField;
<#+ } else { #>
			#warning "<#= TypeName #> does not support Internal IDs."
			throw new InvalidOperationException("<#= TypeName #> does not support Internal IDs.");
<#+ } #>
		}

		/// <summary>
		/// Sets the Internal ID.
		/// </summary>
		/// <param name="id">The Internal ID.</param>
		public override void SetInternalId(string id)
		{
<#+ if (null != TargetType.GetProperty("internalId")) { #>
			this.internalIdField = id;
<#+ } else { #>
			#warning "<#= TypeName #> does not support Internal IDs."
			throw new InvalidOperationException("<#= TypeName #> does not support Internal IDs.");
<#+ } #>
		}
			
<#+ 
		if (SupportsCustomFields)
		{
#>
		/// <summary>
		/// Gets custom field with the given ID or <c>null</c> if a field with the
		/// given ID was not found.
		/// </summary>
		public T FindCustomField<T>(string fieldId) where T: CustomFieldRef
		{
			T match = null;
			if (null != this.customFieldList)
			{
				match = (T)Array.Find(
									this.customFieldList, 
									f => f is T && f.GetInternalId() == fieldId);
			}				
			return match;
		}
			
        /// <summary>
        /// Gets custom field with the given ID or <c>null</c> if a field with the
        /// given ID was not found.
        /// </summary>
        public CustomFieldRef FindCustomField(string fieldId)
		{
			CustomFieldRef match = null;
			if (null != this.customFieldList)
			{
				match = Array.Find(
									this.customFieldList, 
									f => f.GetInternalId() == fieldId);
			}				
			return match;
		}
<#+
		}
#>
	}
}
<#+	
		return this.GenerationEnvironment.ToString();
	}
}
#>

<#+
	IEnumerable<dynamic> GetRecordTypes()
	{
		var assembly = typeof(Record).Assembly;
		// var exclusions = new [] { "InventoryDetail" };
		
		var query = from t in assembly.GetTypes()
					where t.BaseType == typeof(Record) // && !exclusions.Contains(t.Name)
					select new { TargetType = t, TypeName = t.Name };
		
		return query.AsEnumerable<dynamic>();
	}
#>