<#@ template  debug="true" hostSpecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ assembly name="$(ProjectDir)$(OutDir)\ServiceManager.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ assembly name="System.Web.Services" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="com.celigo.net.ServiceManager.SuiteTalk" #>
//~ Generated by CustomFieldGeneratorTemplate.tt
#pragma warning disable 1591

using System;
using System.ComponentModel;
using com.celigo.net.ServiceManager.SuiteTalk;

namespace Celigo.ServiceManager.Utility.Customizations
{
	public static partial class CustomFields
	{
		public static CustomFieldRef Create(string typeName)
		{
			CustomFieldRef fieldRef;
			switch (typeName)
			{
<#	
	var assembly = typeof(CustomFieldRef).Assembly;
		
	var query = from t in assembly.GetTypes()
				where t.BaseType == typeof(CustomFieldRef)
				select t;

	foreach (Type type in query)
	{
#>				case "<#= type.Name #>":
					fieldRef = new <#= type.Name #>();
					break;
<#
	}
#>			
				default:
					throw new ArgumentException(typeName + " is not a valid Custom Field type.");
			}
			return fieldRef;
		}
	}
	
	public static partial class CustomFieldRefExtensions
	{
		public static void SetValue(this CustomFieldRef field, object value)
		{
			<#
	
		foreach (Type type in query)
		{
			#>if (field is <#= type.Name #>)
				((<#= type.Name #>)field).SetValue(value);
			else <#
		}#>if (field != null)
				throw new NotSupportedException(field.GetType().Name + " is not supported.");	
		}
<#
	
		foreach (Type type in query)
		{
			var valueProperty = type.GetProperty("value");
			if (valueProperty != null && valueProperty.PropertyType.IsPrimitive)
			{
#>
		public static void SetValue(this <#= type.Name #> field, object value)
		{
			if (field != null && value == null)
			{
				field.value = default(<#= valueProperty.PropertyType.Name #>);
			}
			else if (field != null)
			{
				var converter = TypeDescriptor.GetConverter(typeof(<#= valueProperty.PropertyType.Name #>));
				if (converter.CanConvertFrom(value.GetType()))
				{
					field.value = (<#= valueProperty.PropertyType.Name #>)converter.ConvertFrom(value);
				}
			}
		}
<#
			}
		}
#>
	}
}
